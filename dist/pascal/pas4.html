<html>
<head>
  <meta http-equiv=Content-Type content="text/html; charset=utf-8">
  <title>Язык программирования Pascal</title>
  <link rel="stylesheet" type="text/css" href="../style/style.css">
  <script type="text/javascript" src="../sh_main.min.js"></script>
  <script type="text/javascript" src="../sh_pascal.min.js"></script>
  <script type="text/javascript" src="../sh_basic.js"></script>
  <link type="text/css" rel="stylesheet" href="../style/sh_nedit.css">
</head>
<body onLoad="sh_highlightDocument();">
<div style="width:80%;">
  <div style="float:right;">
    <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
            codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,0,0"
            width="100" height="50">
      <param name="movie" value="../audio/a_smsqulh3n.swf">
      <param name="bgcolor" value="fff">
      <param name="FlashVars" value="src=9094e666f613f513f50301------------ffffff">
      <param name="autoplay" value="false">
      <embed src="../audio/a_smsqulh3n.swf" bgcolor="fff"
             width="100" height="70" type="application/x-shockwave-flash"
             pluginspage="http://www.macromedia.com/go/getflashplayer"
             FlashVars="src=9094e666f613f513f50301------------ffffff"></embed>
    </object>
  </div>
</div>

<div id="content" style="width:80%;">

<h1>Язык программирования Pascal</h1>

<p><strong>Историческая справка </strong></p>

<p>Создан - 1968 год, швейцарский ученый Никлаус Вирт, название язык получил в честь создателя первой механической
  вычислительной машины Блеза Паскаля, 1985 год - фирма Borland - Turbo Pascal версии 3.0, 1992 год - последняя версия
  языка Turbo Pascal - 7.0, Object Pascal – Delphi, Object Pascal для платформы .NET, Oxygene для платформы .NET,
  Modula-2 – Oberon – Java.</p>

<p><a href="http://en.wikipedia.org/wiki/Delphi_Prism">Delphi Prism</a> для платформы .NET от .</p>

<h2>Алфавит программы</h2>


<p>Простые символы:</p>
<ol start="1" type="1">
  <li>Латинские буквы: <strong>A … </strong><strong>Z,  </strong><strong>a … </strong><strong>z</strong>
    (нечувствительные к регистру)
  </li>
  <li>Цифры: <strong>0 1 2..9</strong></li>
  <li>Знаки математических операций: <strong>+ - * /</strong></li>
  <li>Знаки математических отношений: <strong>&lt; &gt; =</strong></li>
  <li>Знаки препинания: <strong>. , : ;</strong></li>
  <li>Специальные знаки: <strong>{ } [ ] ( ) $ ^</strong> @</li>
</ol>
<p>Составные символы: <strong>:=  &lt;=  &gt;=  (*  *)</strong></p>

<h2>Комментарии</h2>

<p><strong>Комментарии</strong> — пояснения к исходному тексту программы внутри текста программы. Синтаксис комментариев
  определяется языком программирования. Комментарии не оказывают никакого влияния на результат компиляции программы
  или её работу. </p>

<p><strong>Синтаксис комментария.</strong></p>

<pre class="sh_pascal">
// Однострочный комментарий Delphi
{ Многострочный комментарий Pascal }
(* Многострочный
    комментарий *)
</pre>

<p>&nbsp;</p>

<p>Использование комментариев:
  <ul>
  <li>пояснения к тексту программы</li>
  <li>временное отключение фрагментов текста программы</li>
  </ul>. Вложение  комментариев. </p>

<h2>Идентификаторы</h2>

<p>Понятие идентификатора. Синтаксическая диаграмма. Зарезервированные идентификаторы. Пользовательские простые и
  составные идентификаторы. Рекомендации по выбору. Примеры.</p>

<h2>Структура программы</h2>

<p>&nbsp;</p>

<p>Синтаксическая диаграмма. Обязательные и необязательные элементы структуры программы. </p>
<ul>
  <li>Заголовок программы. Назначение. Синтаксическая диаграмма.</li>
  <li>Раздел описаний. Назначение. Синтаксическая диаграмма. Описание меток. Описание констант. Описание типов данных.
    Описание переменных. Описание процедур и функций. Обязательность и последовательность подразделов раздела
    описаний.
  </li>
  <li>Тело программы. Назначение. Синтаксическая диаграмма. Понятие инструкции языка программирования. Простые,
    структурированные и составные (блочные) инструкции. Последовательность выполнения инструкций.
  </li>
</ul>
<p>Примеры.</p>

<h2>Понятие типов данных</h2>

<p>Различные виды информации. Представление данных в памяти компьютера с помощью двоичных кодов. Понятие типов данных
  как средства для интерпретации двоичных данных в качестве различных видов информации. <br>
  Общая классификация типов данных. Предопределенные (встроенные) и пользовательские типы данных. Простые
  (элементарные) и структурированные типы данных. Перечислимые типы данных. Стандартные функции, применимые ко всем
  перечислимым типам: Ord, Pred, Succ, Low, High.</p>

<h2>Понятие констант и переменных</h2>

<p>&nbsp;</p>

<p>Назначение констант и переменных в программе. Строгая типизация.</p>

<p>Константы-литералы. Именованные константы. Типизированные константы. Описание именованных и типизированных констант в
  программе в подразделе описания констант. Примеры.</p>

<p>Переменные. Описание переменных в программе. Особенности использования переменных. Примеры.</p>

<h2>Предопределенные типы данных</h2>

<h3>Целые типы данных</h3>

<p>&nbsp;</p>

<p>Назначение. Перечислимый тип. Подтипы: Byte, ShortInt, Integer, Word, LongInt. Представление в памяти и диапазоны
  значений. Константы-литералы. Шестнадцатеричные константы-литералы.  Описание именованных констант. Описание
  переменных. Математические операции: +, -, *, /, div, mod. Специальные операции: NOT, AND, OR, XOR, Shl, Shr.
  Математические функции. Операции отношения. Примеры. Выполнение действий над отдельными битами памяти с помощью
  специальных операций.</p>

<h3>Вещественные типы данных</h3>

<p>Назначение. Не перечислимый тип. Подтипы: Real, Single, Double, Extended, Comp. Представление в памяти и диапазоны
  значений. Константы-литералы. Описание именованных констант и переменных. Математические операции: +, -, *, /.
  Математические функции. Операции отношения. Примеры.</p>

<h3>Символьный тип данных</h3>

<p>Назначение. Перечислимый тип. Представление в памяти и диапазон значений. Таблицы символов. Управляющие символы.
  Способы записи констант-литералов. Описание именованных констант и переменных. Функция Chr. Операции отношения.
  Примеры.</p>

<h3>&nbsp;</h3>

<h3><a name="_Toc285537963"></a><a name="_Toc285281010">4.7.4. Логический  тип данных</a></h3>

<p>&nbsp;</p>

<p>Назначение. Перечислимый тип. Представление в памяти и значения. Способы записи констант-литералов. Описание
  переменных. Логические операции NOT, AND, OR, XOR. Операции отношения. Примеры построения сложных логических
  выражений. Полное и укороченное вычисление логических выражений.</p>

<h3><a name="_Toc285537964"></a><a name="_Toc285281011">4.7.5. Предварительное знакомство со строковым
  типом данных</a></h3>

<p>&nbsp;</p>

<p>Назначение. Не перечислимый тип. Представление в памяти и значения. Способы записи констант-литералов. Пустая строка.
  Описание переменных. Ограничение длины строки. Операция объединения строк. Операции отношения. Процедуры и функции
  обработки строк: Length, Copy, Pos, Insert, Delete, UpCase, Val, Str. Использование процедуры Val для защищенного
  ввода числовых данных. Другие примеры.</p>

<h2><a name="_Toc285537965"></a><a name="_Toc285281012">Пользовательские простые типы данных</a></h2>

<p>&nbsp;</p>

<h3><a name="_Toc285537966"></a><a name="_Toc285281013">Пользовательский перечислимый тип данных</a></h3>

<p>Назначение. Задание  типа данных в разделе описаний типов или в разделе описания переменных. Примеры.
  Ограничения.</p>

<h3><a name="_Toc285537967"></a><a name="_Toc285281014">Интервальный тип данных</a></h3>

<p>&nbsp;</p>

<p>Назначение. Задание  типа данных в разделе описаний типов или в разделе описания переменных. Примеры.
  Ограничения.</p>

<h2><a name="_Toc285537968"></a><a name="_Toc285281015">Инструкция присваивания и выражения</a></h2>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Простейшие примеры. Совместимость типов данных. Приведение типов данных.
  Понятие выражения.<br>
  Арифметические выражения. Порядок выполнения операций. Приоритет операций. Использование скобок. Определение типа
  результата вычисления арифметического выражения. Примеры.<br>
  Логические выражения. Правила использования операций отношения и логических операций при построении логических
  выражений. Приоритет операций. Примеры.<br>
  Строковые выражения. Примеры.</p>

<h2><a name="_Toc285537969"></a><a name="_Toc285281016"> Простейшие формы инструкций ввода – вывода</a>
</h2>

<p>&nbsp;</p>

<p>Назначение инструкций ввода – вывода и их значение. Устройства ввода – вывода. Работа с экраном и клавиатурой.</p>

<h3><a name="_Toc285537970"></a><a name="_Toc285281017">4.10.1. Инструкция вывода данных на экран</a>
</h3>

<p>&nbsp;</p>

<p>Две формы инструкции вывода: Write и Writeln. Особенности этих форм. Синтаксическая диаграмма. Список вывода. Типы
  данных элементов списка вывода. Форматирование данных при их выводе. Примеры. Организация вывода на экран значений
  пользовательского перечислимого типа данных.</p>

<h3><a name="_Toc285537971"></a><a name="_Toc285281018">4.10.2. Инструкция ввода данных с клавиатуры</a>
</h3>

<p>&nbsp;</p>

<p>Две формы инструкции ввода: Read и Readln. Синтаксическая диаграмма. Список ввода. Типы данных элементов списка
  ввода. Особенности ввода данных различных типов. Ошибки при вводе числовых данных. Функция IOResult. Организация
  ввода данных с клавиатуры. Понятие буфера клавиатуры. Особенности использования  инструкций Read и Readln. Возможные
  ошибки при использовании инструкции Read. Примеры. Организация ввода с клавиатуры значений пользовательского
  перечислимого типа данных. Функция READKEY модуля CRT.</p>

<h2> <a name="_Toc285537972"></a><a name="_Toc285281019">Инструкции выбора</a></h2>

<p>Линейные и ветвящиеся алгоритмы. Назначение и виды инструкций выбора.</p>

<h3><a name="_Toc285537973"></a><a name="_Toc285281020">Условная инструкция (</a>IF) </h3>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Блок-схемы полной и укороченной форм инструкции. Вложение инструкций.
  Оптимизация многоуровневых вложения путем построения сложных логических выражений. Примеры реализации различных
  ветвящихся алгоритмов.</p>

<h3><a name="_Toc285537974"></a><a name="_Toc285281021">Инструкция </a>CASE </h3>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Блок-схема. Допустимые типы данных выражения выбора и меток инструкции.
  Различные варианты записи меток ветвей инструкции. Примеры использования. Эффективность по сравнению с
  использованием условной инструкции.</p>

<h3><a name="_Toc285537975"></a><a name="_Toc285281022">Инструкция безусловного перехода (</a>GOTO) </h3>

<p> <br>
  Назначение. Синтаксис. Определение меток в разделе описаний. Недостатки инструкции. Нежелательность ее
  использования.</p>

<h2> <a name="_Toc285537976"></a><a name="_Toc285281023">Циклические алгоритмы</a></h2>

<p>&nbsp;</p>

<p>Примеры циклических алгоритмов. Их важность и эффективность. Различные виды циклов. Виды инструкций для реализации
  циклических алгоритмов.</p>

<h3><a name="_Toc285537977"></a><a name="_Toc285281024">Цикл на заданное число повторений
  (инструкция </a>FOR) </h3>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Блок-схема. Допустимые типы данных управляющей переменной цикла. Выражения,
  задающие начальное и конечное значения управляющей переменной. Правила оформления тела цикла. Недопустимость
  принудительного изменения значения управляющей переменной внутри тела цикла. Вложение циклов друг в друга.
  Примеры.</p>

<h3><a name="_Toc285537978"></a><a name="_Toc285281025">Цикл с предусловием (инструкция </a>WHILE) </h3>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Блок-схема. Логическое выражение продолжения цикла. Тело цикла. Меры по
  предотвращению зацикливания. Вложение циклов. Отличия от цикла FOR. Рекомендации по использованию. Примеры.</p>

<h3><a name="_Toc285537979"></a><a name="_Toc285281026">Цикл с постусловием (инструкция </a>REPEAT) </h3>

<p>&nbsp;</p>

<p>Назначение. Синтаксическая диаграмма. Блок-схема. Логическое выражение окончания цикла. Тело цикла. Меры по
  предотвращению зацикливания. Вложение циклов. Отличия от цикла FOR и WHILE. Рекомендации по использованию.
  Примеры.</p>

<p>Операторы Break и Continue. Моделирование одного цикла другими. Реализация циклов с шагом.</p>

<h2> <a name="_Toc285537980"></a><a name="_Toc285281027">Массивы</a></h2>

<p>&nbsp;</p>

<p>Понятие одномерных и многомерных статических массивов. Пользовательский структурированный тип. Связь массивов и
  циклов. Индексы элементов и элементы массивов. Возможные типы данных индексов массивов. Типы данных элементов
  массивов. Определение типа данных одномерного массива в разделе описания типов данных и в разделе описания
  переменных. Размещение и размер массива в памяти. Различные способы определения типа данных многомерных массивов.
  Обращение к отдельным элементам одномерных и многомерных массивов, эффективность этой операции. Типовые задачи при
  обработке массивов (начальная инициализация; ввод-вывод элементов массивов; вычисления над значениями элементов
  массивов; поиск максимальных и минимальных значений; отбор элементов массивов; перестановка элементов массивов;
  сортировка одномерных массивов; построчная обработка двумерных массивов и т.д.). Определение типизированных констант
  тапа массива.</p>

<h2> <a name="_Toc285537981"></a><a name="_Toc285281028">Детальное изучение строкового типа данных</a>
</h2>

<p>&nbsp;</p>

<p>Представление типа STRING как массива. Использование нулевого символа для определения текущей длины строки. Почему
  длина текстовой  строки ограничена 255 символами. Доступ к отдельным символам текстовой строки. Посимвольная
  обработка строк. Примеры. Манипуляции с нулевым символом строки. Примеры. </p>

<h2> <a name="_Toc285537982"></a><a name="_Toc285281029">Процедуры и функции</a></h2>

<h3><a name="_Toc285537983"></a><a name="_Toc285281030">Общие сведения</a></h3>

<p>&nbsp;</p>

<p>Понятие подпрограммы. Значение подпрограмм при конструировании программ. Понятие процедур и функций. Синтаксическая
  диаграмма структуры подпрограммы. Синтаксические диаграммы заголовков процедур и функций. Список параметров. Типы
  параметров. Параметры значения и параметры переменные. Понятие стека. Сравнительные характеристики параметров
  значений и параметров переменных. Сравнение их эффективности с точки зрения использования памяти и быстродействия.
  Ограничения на типы данных значений, возвращаемых через имя функции. Раздел описаний процедур и функций. Различия в
  теле процедуры и функции. Вызов процедур и функций. Формальные и фактические параметры. Особенности подстановки
  фактических параметров при вызове процедуры или функции. Возможность вызова функции как процедуры. Вложение процедур
  и функций. Использование не типизированных параметров переменных. Открытые массивы.</p>

<h3><a name="_Toc285537984"></a><a name="_Toc285281031">Глобальные и локальные данные</a></h3>

<p>&nbsp;</p>

<p>Понятие глобальных и локальных данных. Видимость объектов. Относительность понятий глобальных и локальных данных.
  Примеры. Перекрытие глобальных объектов локальными объектами при совпадении имен. Достоинства и недостатки.
  Ограничения на определение управляющей переменной цикла FOR (должна быть локальной переменной).</p>

<h3><a name="_Toc285537985"></a><a name="_Toc285281032">Перекрестный вызов процедур и функций</a></h3>

<p>&nbsp;</p>

<p>Понятие перекрестного вызова. Опережающее описание процедур и функций. Директива FORWARD. Указание параметров при
  опережающем описании процедуры или функции. </p>

<h3><a name="_Toc285537986"></a><a name="_Toc285281033">Рекурсии</a></h3>

<p>Понятие рекурсивного вызова процедур и функций. Примеры использования рекурсивного вызова. Эффективность рекурсий.
  Возможные ошибки при использовании рекурсий (переполнение стека, управление размером стека). </p>

<h3><a name="_Toc285537987"></a><a name="_Toc285281034">Процедурный тип данных</a></h3>

<p>&nbsp;</p>

<p>Понятие процедурного типа данных. Синтаксис. Переменные процедурного типа. Операции с процедурным типом данных.
  Примеры. Использование процедурных типов в качестве параметров процедур и функций. Директива дальних вызовов FAR.
  Примеры использования параметров процедурного типа для создания универсальных алгоритмов обработки.</p>

<h3><a name="_Toc285537988"></a><a name="_Toc285281035">Использование процедур и функций при нисходящем
  проектировании</a></h3>

<p>Пошаговая детализация алгоритма обработки с помощью процедур и функций. Понятие процедур и функций – заглушек.
  Принцип максимальной изолированности  процедур и функций. Распределение работ при коллективной работе над
  проектом.</p>

<h2> <a name="_Toc285537989"></a><a name="_Toc285281036">Модули</a></h2>

<p>Понятие модуля. Назначение и использование модулей. Синтаксическая диаграмма структуры модуля. Заголовок модуля.
  Интерфейсная часть модуля. Ее назначение и состав. Реализационная часть модуля. Ее назначение и состав.
  Инициализационная часть модуля - назначение и состав. Использование других модулей. Перекрестное использование
  модулей. Подключение модулей к программе. Особенности компиляции модулей. Примеры. Рекомендации при публикации
  модулей.<br>
  Краткий обзор некоторых стандартных модулей и дополнительных модулей поставки Turbo Pascal (CRT, SYSTEM, DOS, Turbo
  Vision). Наиболее известные модули третьих сторон (Turbo Professional).</p>

<h2> <a name="_Toc285537990"></a><a name="_Toc285281037">Записи</a></h2>

<h3><a name="_Toc285537991"></a><a name="_Toc285281038">Простые записи</a></h3>

<p>&nbsp;</p>

<p>Назначение типа данных. Пользовательский структурированный тип данных. Определение типа данных в разделе описания
  типов и переменных. Синтаксическая диаграмма. Типы данных полей. Размещение и размер записи в памяти. Функция
  SizeOf. Вложенные записи. Доступ к полям записи. Операции с записями и с их полями. Инструкция WITH. Ввод-вывод
  записей.</p>

<h3><a name="_Toc285537992"></a><a name="_Toc285281039">Записи с вариантами</a></h3>

<p>Назначение типа данных. Синтаксическая диаграмма определения типа. Общая и вариантная части записи. Поле выбора и
  варианты. Два способа определения поля выбора. Связь типа поля выбора и типа меток вариантов. Описание вариантов
  записи. Доступ к полям вариантной записи. Использование записей с вариантами.</p>

<h2> <a name="_Toc285537993"></a><a name="_Toc285281040">Множества</a></h2>

<p>Назначение типа данных. Пользовательский структурированный тип данных. Синтаксическая диаграмма определения типа.
  Базовый тип элементов множества. Мощность множества. Подмножества. Область значений множества. Конструктор
  множества. Определение констант. Пустое подмножество.<br>
  Операции над множествами. Объединение (+). Разность (-). Пересечение (*). Операции отношения (=, &lt;&gt;, &gt;=,
  &lt;=). Вхождение элемента во множество (in). <br>
  Использование множеств. Примеры.</p>

<h2> <a name="_Toc285537994"></a><a name="_Toc285281041">Работа с файлами</a></h2>

<p>&nbsp;</p>

<p>Понятие файла. Назначение и использование файлов. Три разновидности определения файлов. Пользовательский
  структурированный тип данных. Синтаксические диаграммы определения типа файлов в разделе описаний. Структура файлов.
  Понятие компонента (записи) файла. Понятие файловой переменной. Операции с файловыми переменными. Использование
  файловых переменных в качестве параметров процедур и функций.<br>
  Общие операции по работе с файлами. Связывание файловой переменной с конкретным файлом. Имя файла. Создание нового
  файла. Открытие существующего файла. Возможные ошибки при создании и открытии файлов. Безопасные средства для
  открытия файлов (функция IOResult). Закрытие файлов. Удаление файлов. Переименование файлов.</p>

<h3><a name="_Toc285537995"></a><a name="_Toc285281042">Текстовые файлы</a></h3>

<p>Назначение текстовых файлов. Внутренняя структура. Разбиение текста на строки. Посимвольное и построчное чтение
  данных из текстового файла (инструкции READ и READLN). Функции EOLN и EOF. Примеры чтения данных из текстовых
  файлов. Запись данных в текстовые файлы (инструкции WRITE и WRITELN). Примеры записи данных в текстовые файлы.
  Копирование текстовых файлов. Коррекция текста в текстовых файлах. </p>

<h3><a name="_Toc285537996"></a><a name="_Toc285281043">Типизированные файлы</a></h3>

<p>&nbsp;</p>

<p>Назначение типизированных файлов. Внутренняя структура. Отличия от текстовых файлов. Типы данных компонентов. Понятие
  указателя файла. Прямой доступ к любому компоненту файла. Процедура SEEK. Нумерация компонентов файла. Функция
  FILEPOS. Определение количества компонентов файла (функция FILESIZE). Чтение и запись данных в типизированных файлах
  (инструкции READ и WRITE). Коррекция компонентов. Удаление и вставка компонентов в типизированных файлах путем
  перезаписи файла. Более эффективные средства удаления и вставки компонентов (без перезаписи файлов). Копирование
  типизированных файлов.</p>

<h3><a name="_Toc285537997"></a><a name="_Toc285281044">Не типизированные файлы</a></h3>

<p>&nbsp;</p>

<p>Понятие не типизированного файла. Области использования. Достоинства использования. Особенности использования
  процедур RESET и REWRITE. Компоненты не типизированного файла. Операции SEEK, FILEPOS и FILESIZE. Особенности чтения
  и записи данных в не типизированных файлах (процедуры BLOCKREAD и BLOCKWRITE). Рекомендации. Примеры. Универсальная
  процедура копирования файлов.</p>

<h3><a name="_Toc285537998"></a><a name="_Toc285281045">Организация печати данных</a></h3>

<p>&nbsp;</p>

<p>Стандартный модуль PRINTER. Файловая переменная LST. Некоторые способы управления печатью.</p>

<h2> <a name="_Toc285537999"></a><a name="_Toc285281046">Ссылочные типы данных</a></h2>

<h3><a name="_Toc285538000"></a><a name="_Toc285281047">Динамическая память и динамические объекты</a>
</h3>

<p>&nbsp;</p>

<p>Понятие статических и динамических объектов. Недостатки статических объектов. Достоинства и области использования
  динамических объектов. Понятие динамической памяти. Карта памяти. Особенности использования динамической памяти.
  Проблема утечки памяти.</p>

<h3><a name="_Toc285538001"></a><a name="_Toc285281048">Ссылочные типы данных</a></h3>

<p>Понятие ссылки. Определение ссылочных типов данных в разделе описаний. Переменная ссылочного типа – статическая
  переменная (4 байта). Пустая ссылка (константа NIL). Создание динамического объекта (процедура NEW). Удаление
  динамического объекта (процедура  DISPOSE). Обращение к динамическому объекту. Операции со ссылочными переменными.
  Характерные ошибки при работе со ссылочными типами данных. Рекомендации по использованию ссылочных типов и по борьбе
  с утечкой памяти. Примеры.<br>
  Понятие не типизированной ссылки (указатель - POINTER). Совместимость указателя со ссылочными типами данных.
  Особенности использование указателей. Преобразование типов данных. Наложение переменных в памяти (директива
  ABSOLUTE)<br>
  Другие средства работы с динамической памятью. Парные процедуры MARK и RELEASE. Примеры их использования. Парные
  процедуры GETMEM и FREEMEM. Примеры их использования. Функции MEMAVAIL и MAXAVAIL. Пример выделения временного
  буфера при работе с не типизированными файлами.</p>

<h3><a name="_Toc285538002"></a><a name="_Toc285281049">Одномерные и многомерные списки</a></h3>

<p>Понятие динамических структур. Использование ссылочных типов данных для работы с динамическими структурами. <br>
  Понятие одномерного односвязного списка. Определение необходимых типов данных. Создание одномерного списка. Удаление
  одномерного списка. Доступ к элементам одномерного списка. Добавление новых элементов в список и удаление элементов
  из списка. Достоинства и недостатки односвязного списков. Двухсвязные списки. <br>
  Понятие двумерного списка. Определение необходимых типов данных. Создание двумерного списка. Удаление двумерного
  списка. Доступ к элементам двумерного списка. <br>
  Принципы создания списков любой мерности.</p>

<h3><a name="_Toc285538003"></a><a name="_Toc285281050">Стеки</a></h3>

<p>Понятие стека. Области использования. Принципы работы со стеком. Необходимые типы данных. Добавление элементов в
  стек. Извлечение элементов стека.</p>

<h3><a name="_Toc285538004"></a><a name="_Toc285281051">Деревья</a></h3>

<p>Принципы построения деревьев. Основные приемы работы с деревьями. Рекурсивный поиск  на дереве.<br>
</p>

<h2> <a name="_Toc285538005"></a><a name="_Toc285281052">Работа с памятью</a></h2>

<h3><a name="_Toc285538006"></a><a name="_Toc285281053">Средства для работы с памятью</a></h3>

<p>Общие принципы работы с памятью.  Процедуры и функции для работы с памятью (ADDR, OFS, SEG, PTR, MOVE, FILLCHAR,
  оператор @).</p>

<h3><a name="_Toc285538007"></a><a name="_Toc285281054">Динамические массивы</a></h3>

<p>&nbsp;</p>

<p>Принципы создания динамических массивов. Создание и уничтожение одномерного динамического массива. Доступ к элементам
  динамического массива по индексу элемента.<br>
  Двумерные динамические массивы. Создание и уничтожение. Доступ к элементам. <br>
  Пример модуля для работы с динамическими массивами.</p>

<h2> <a name="_Toc285538008"></a><a name="_Toc285281055">Тип данных </a>TObject (введение в ООП) </h2>

<p>&nbsp;</p>

<p>Идея объектно-ориентированного программирования. Объекты и их иерархия. Связь и различия между типом запись и типом
  TObject. Экземпляры объектов. Наследование в записях и объектах. Свойства объектов. Методы объектов. Инкапсуляция.
  Виртуальные методы и полиморфизм. Конструкторы и деструкторы. Примеры. </p>

<p>&nbsp;</p>

<h1 align="center"><a name="_Toc285538009">Отладка и тестирование программ</a></h1>

<p>Принципы отладки программ. Использование отладчика среды разработки. Отладочные коды в тексте программ. Директивы
  условной компиляции и отладка.<br>
  Основы тестирования программ. Назначения, правила построения тестов, их использование.</p>

<h1 align="center"><a name="_Toc285538010">Документирование алгоритмов и программ</a></h1>

<p>&nbsp;</p>

<p>Необходимость документирования. Состав, структура и функции программной документации. Система стандартов,
  определяющих документирование алгоритмов и программ.</p>

<p>&nbsp;</p>

<h2>Записи и оператор with</h2>

<p>Записи используются для создания своих типов данных</p>

<pre class="sh_pascal">
{ Обьявление записи - тип "Точка" }  
type 
  TPoint = Record 
    x,y : double;
  end;
  
{ Функция, вычисляющая расстояние между точками }   
function dist( A,B : TPoint ):double;
begin
  dist := sqrt( (A.x - B.x)*(A.x - B.x) + (A.y - B.y)*(A.y - B.y) );
end;

{ Использование записей }
var A,B : TPoint;
begin
  { Инициализируем координаты точек }
  A.x := 1; A.y := 2;
  B.x := 10; B.y := 11;
  writeln( dist(A,B) );   
end.
</pre>

<p>Использование with:</p>

<pre class="sh_pascal">
{ Обьявление записи - тип "Персонаж в игре" }
type 
  TUnit = Record 
    x,y : integer; { Координаты клетки где стоит персонаж }  
    name : string; { Имя персонажа }
  end;

var Unit1 : TUnit;

{ Инициализация без with }
Unit1.x := 2; 
Unit1.y := 3;
Unit1.name := 'SUPER-HERO';

{ Инициализация с with }
with Unit1 do begin
  x := 2; 
  y := 3;
  name := 'SUPER-HERO';
end;  
</pre>

<h2>Реализация Стека и Очереди на базе массива</h2>

<p>
  <strong>Стек</strong> (англ. <strong>stack</strong> — стопка) — структура данных с методом доступа к элементам
  <strong>LIFO</strong> (англ. Last In — First Out, «последним пришёл — первым вышел»). Чаще всего принцип работы
  стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю. </p>

<img src="img/stack.png">

<pre class="sh_pascal">
const StackSize = 10000; { Размер стека (сколько в него можно положить элементов) }

{ === Хранение стека === }
var
  Stack : array [1..StackSize] of Integer; { Массив для хранения стека }
  StackTop : Integer = 0; { Вершина стека - индекс в массиве Stack }

{ === Операции со стеком === }

{ Стек пуст? }
function isEmpty : Boolean;
begin
  isEmpty := StackTop = 0;
end;

{ Положить значение на вершину стека }
procedure Push( Value : Integer );
begin
  assert( StackTop &lt; StackSize, 'Стек полон! Больше положить в него нельзя!');
  Inc(StackTop);
  Stack[StackTop] := Value;
end;

{ Забрать значение с вершины стека }
function Pop : Integer;
begin
  assert( not isEmpty, 'Нельзя извлечь элемент, потому что стек пуст!');
  Pop := Stack[StackTop];
  Dec( StackTop );
end;

{ === Тестирование работы стека === }
begin
  Writeln(isEmpty); { Выводит "TRUE" - стек пуст }
  Push(2); { В стеке: 2 }
  Writeln(isEmpty); { Выводит "FALSE" - стек не пуст }
  Push(5); { В стеке: 2, 5 }
  Writeln(Pop); { Выводит "5", в стеке: 2 }
  Writeln(Pop); { Выводит "2", в стеке пусто }
end.</pre>

<p>
  <strong>Очередь</strong> — структура данных с дисциплиной доступа к элементам «первый пришёл — первый вышел»
  (<strong>FIFO</strong>, First In — First Out). Добавление элемента (принято обозначать словом enqueue — поставить в
  очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue —
  убрать из очереди), при этом выбранный элемент из очереди удаляется. </p>

<p><img src="img/queue.gif" width="517" height="214" alt="Очередь" longdesc="img/queue.gif"></p>

<p>&nbsp;</p>

<pre class="sh_pascal">
const QSize = 10000; { Размер очереди (сколько в неё можно положить элементов) }
var
  Q : array [1..QSize] of Integer; { Массив для хранения очереди }
  Q_Start : Integer = 1; { Указывает на голову очереди }
  Q_End : Integer = 1; { Указывает на элемент, который заполнится, когда в очередь войдёт новый элемент }

{ = Операции с очередью = }

{ Очередь пуста? }
function isEmpty : Boolean;
begin
  isEmpty := Q_Start = Q_End;
end;

{ Положить значение в конец очереди }
procedure Put( Value : Integer );
begin
  Q[Q_End] := Value;
  Dec(Q_End);
  { Поддержка закольцованности очереди }
  if Q_End < 1 then Q_End := QSize;
end;

{ Забрать значение с начала очереди }
function Get : Integer;
begin
  assert( not isEmpty, 'В очереди ничего нет!');
  Get := Q[Q_Start];
  Dec(Q_Start);
  { Поддержка закольцованности очереди }
  if Q_Start < 1 then Q_Start := QSize;
end;

begin
  Writeln(isEmpty); { Выводит "TRUE" - очередь пуста }
  Put(2); { В очереди: 2 }
  Writeln(isEmpty); { Выводит "FALSE" - очередь не пуста }
  Put(5); { В очереди: 5, 2 }
  Writeln(Get); { Выводит "2", в очереди: 5 }
  Writeln(Get); { Выводит "5", в очереди пусто }
end.
</pre>

</div>
</body>

</html>
